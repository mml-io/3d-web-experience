import crypto from "crypto";

import type { UserData } from "@mml-io/3d-web-user-networking";
import { CharacterDescription, UserIdentity } from "@mml-io/3d-web-user-networking";
import express from "express";
import { JSDOM } from "jsdom";

type UserPermissions = {
  allowUsername: boolean;
};

export type AuthUser = {
  // clientId is the connection identifier for the user - it is null before the client websocket is connected
  clientId: number | null;
  // userId is the identifier for the user that is generated when the user is authenticated - it could be an external identifier
  userId: string;
  // userData is the user's presentation in the world (username and character description)
  userData: UserData;
  // itemSrcs is the set of item sources that the user is using in their character description
  itemSrcs: Set<string>;
  // sessionToken is the token that is generated by this authenticator and the user uses to authenticate their websocket connection
  sessionToken: string;
  // permissions is the set of permissions that the user has based on their authentication - it could be used to control the user's actions after loading
  permissions: UserPermissions;
};

export const botWithHatCharacter: CharacterDescription = {
  mmlCharacterString: `
    <m-character src="/assets/models/bot.glb">
        <m-model src="/assets/models/hat.glb"
        socket="head"
        x="0.03" y="0" z="0.0"
        sx="1.03" sy="1.03" sz="1.03"
        rz="-90"
        ></m-model>
    </m-character>
    `,
};

export const botCharacter: CharacterDescription = {
  mmlCharacterString: `<m-character src="/assets/models/bot.glb"></m-character>`,
};

/*
 This user-authenticator is intended to demonstrate that the user's identity and character description can be
 updated after the initial connection and the server can control the result.

 It also shows that given some trigger, the server can update the user's character description (i.e. based on the items
 being revoked/transferred).
*/
export class ExampleEnforcingUserAuthenticator {
  private usersByClientId = new Map<number, AuthUser>();
  private userByUserId = new Map<string, AuthUser>();
  private userBySessionToken = new Map<string, AuthUser>();

  // Define some items that can be used in the character description and the rules over their usage
  private itemsBySrc = new Map<
    string,
    | {
        // This item can only be used by specific users
        restricted: true;
        allowedUsers: Set<string>;
      }
    | {
        restricted: false;
      }
  >([
    ["/assets/models/bot.glb", { restricted: false }],
    ["/assets/models/hat.glb", { restricted: true, allowedUsers: new Set() }],
  ]);

  constructor(
    private options: {
      updateUserCharacter: (clientId: number, userData: UserData) => void;
    },
  ) {}

  public generateAuthorizedSessionToken(req: express.Request): string | null {
    const sessionToken = crypto.randomBytes(20).toString("hex");

    const resultUserId = crypto.randomBytes(5).toString("hex");

    let resultCharacterDescription: CharacterDescription = botCharacter;
    let resultUsername = "Guest";
    const resultPermissions: UserPermissions = {
      allowUsername: false,
    };

    if (req.query.passphrase === "ThatKillsPeople") {
      resultPermissions.allowUsername = true;
      this.setAllowedUsersforItemSrc("/assets/models/hat.glb", new Set([resultUserId]));
      const foundCharacter = botWithHatCharacter;
      if (foundCharacter) {
        resultCharacterDescription = foundCharacter;
      }
    }
    if (resultPermissions.allowUsername && req.query.username) {
      resultUsername = req.query.username as string;
    }

    const authorizedCharacterDescription = this.getAuthorizedCharacterDescription(
      resultUserId,
      resultCharacterDescription,
    );
    if (!authorizedCharacterDescription) {
      console.error(`The generated character description was unauthorized`);
      return null;
    }

    const { characterDescription, srcs } = authorizedCharacterDescription;

    console.log(`Generated sessionToken for userId ${resultUserId}`);
    const authUser: AuthUser = {
      clientId: null,
      userData: { username: resultUsername, characterDescription: characterDescription },
      itemSrcs: srcs,
      sessionToken,
      userId: resultUserId,
      permissions: resultPermissions,
    };

    this.userByUserId.set(resultUserId, authUser);
    this.userBySessionToken.set(sessionToken, authUser);
    return sessionToken;
  }

  public setAllowedUsersforItemSrc(itemSrc: string, allowedUsers: Set<string>) {
    const item = this.itemsBySrc.get(itemSrc);
    if (!item) {
      console.error(`Item ${itemSrc} not found`);
      return;
    }
    if (!item.restricted) {
      console.error(`Item ${itemSrc} not restricted`);
      return;
    }

    const impactedUsers = new Set<string>();
    for (const [userId, user] of this.userByUserId) {
      if (user.itemSrcs.has(itemSrc)) {
        impactedUsers.add(userId);
      }
    }

    item.allowedUsers = allowedUsers;

    for (const userId of impactedUsers) {
      this.checkUserCharacter(userId);
    }
  }

  // This removes any mml-tags using src attributes that are not permitted for the user
  public getAuthorizedCharacterDescription(
    userId: string,
    characterDescription: CharacterDescription,
  ): { characterDescription: CharacterDescription; srcs: Set<string> } | null {
    const mmlCharacterString = characterDescription.mmlCharacterString ?? null;
    if (mmlCharacterString === null) {
      console.error("Character description is not MML string");
      // TODO - support MML urls
      return null;
    }

    const dom = new JSDOM(mmlCharacterString);
    const doc = dom.window.document;
    const srcs = new Set<string>();
    for (const element of doc.querySelectorAll("*")) {
      const src = element.getAttribute("src");
      if (src) {
        if (this.canUseSrc(userId, src)) {
          srcs.add(src);
        } else {
          console.warn(`Remove ${src} from character: Not permitted for user ${userId}`);
          element.parentNode?.removeChild(element);
        }
      }
    }

    const authorizedCharacterDescription = { mmlCharacterString: doc.body.innerHTML };
    return {
      characterDescription: authorizedCharacterDescription,
      srcs,
    };
  }

  private checkUserCharacter(userId: string) {
    const user = this.userByUserId.get(userId);
    if (!user) {
      console.error(`User ${userId} not found`);
      return;
    }
    if (!user.clientId) {
      console.error(`User ${userId} not connected`);
      return;
    }
    const authorizedCharacterDescription = this.getAuthorizedCharacterDescription(
      userId,
      user.userData.characterDescription,
    );
    if (!authorizedCharacterDescription) {
      console.error(`Unauthorized character update for ${userId}`);
      return;
    }
    user.userData = {
      characterDescription: authorizedCharacterDescription.characterDescription,
      username: user.userData.username,
    };
    user.itemSrcs = authorizedCharacterDescription.srcs;
    this.options.updateUserCharacter(user.clientId, user.userData);
  }

  public onClientConnect(
    clientId: number,
    sessionToken: string,
    userIdentityPresentedOnConnection?: UserIdentity,
  ): UserData | null {
    console.log(`Client ID: ${clientId} joined with token`);
    const user = this.userBySessionToken.get(sessionToken);
    if (!user) {
      console.error(`Invalid initial user-update for clientId ${clientId}, unknown session`);
      return null;
    }

    if (user.clientId !== null) {
      console.error(`User ${user.userId} already connected`);
      return null;
    }

    user.clientId = clientId;
    if (userIdentityPresentedOnConnection) {
      user.userData = {
        username: userIdentityPresentedOnConnection.username || user.userData.username,
        characterDescription:
          userIdentityPresentedOnConnection.characterDescription ||
          user.userData.characterDescription,
      };
    }
    this.usersByClientId.set(clientId, user);
    return user.userData;
  }

  public getClientIdForSessionToken(sessionToken: string): { id: number } | null {
    const user = this.userBySessionToken.get(sessionToken);
    if (!user) {
      console.error("getClientIdForSessionToken - unknown session");
      return null;
    }
    if (user.clientId === null) {
      console.error("getClientIdForSessionToken - client not connected");
      return null;
    }
    return { id: user.clientId };
  }

  public onClientUserIdentityUpdate(
    clientId: number,
    newUserIdentity: UserIdentity,
  ): UserData | null {
    const user = this.usersByClientId.get(clientId);
    if (!user) {
      console.error(`Invalid user-update for clientId ${clientId}, unknown user`);
      return null;
    }

    const existingUserIdentity = user.userData;
    let newUsername = existingUserIdentity.username;
    let newSrcs = user.itemSrcs;
    let newCharacterDescription = existingUserIdentity.characterDescription;

    if (newUserIdentity.characterDescription) {
      const authorizedCharacterUpdate = this.getAuthorizedCharacterDescription(
        user.userId,
        newUserIdentity.characterDescription,
      );
      if (!authorizedCharacterUpdate) {
        console.error(`Unauthorized character update for clientId ${clientId}`);
        return null;
      }
      newCharacterDescription = authorizedCharacterUpdate.characterDescription;
      newSrcs = authorizedCharacterUpdate.srcs;
    }

    if (newUserIdentity.username !== null) {
      if (!user.permissions.allowUsername) {
        console.error(`No permissions to change username for ${user.userId}.`);
        return null;
      }
      newUsername = newUserIdentity.username;
    }

    const newUserData: UserData = {
      username: newUsername,
      characterDescription: newCharacterDescription,
    };
    user.userData = newUserData;
    user.itemSrcs = newSrcs;
    return newUserData;
  }

  public onClientDisconnect(clientId: number) {
    console.log(`Remove user-session for ${clientId}`);
    // TODO - expire session token after a period of disconnection
    const userData = this.usersByClientId.get(clientId);
    if (userData) {
      userData.clientId = null;
      this.usersByClientId.delete(clientId);
    }
  }

  private canUseSrc(userId: string, src: string) {
    const item = this.itemsBySrc.get(src);
    if (!item) {
      console.error(`Item ${src} not found. Cannot be used.`);
      return false;
    }
    if (!item.restricted) {
      return true;
    }
    return item.allowedUsers.has(userId);
  }
}
