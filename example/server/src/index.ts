import path from "path";
import url from "url";

import dolbyio from "@dolbyio/dolbyio-rest-apis-client";
import * as jwtToken from "@dolbyio/dolbyio-rest-apis-client/dist/types/jwtToken";
import { ChatNetworkingServer } from "@mml-io/3d-web-text-chat";
import type { CharacterDescription, UserData } from "@mml-io/3d-web-user-networking";
import { UserIdentity, UserNetworkingServer } from "@mml-io/3d-web-user-networking";
import cors from "cors";
import dotenv from "dotenv";
import express from "express";
import enableWs from "express-ws";
import WebSocket from "ws";

import { authMiddleware } from "./auth";
import { BasicUserAuthenticator } from "./BasicUserAuthenticator";
import { ExampleEnforcingUserAuthenticator } from "./example-character-customisation-auth/ExampleEnforcingUserAuthenticator";
import { addLocalMultiWebAppRoutes } from "./router/local-multi-web-client-app-routes";
import { MMLDocumentsServer } from "./router/MMLDocumentsServer";
import { addWebAppRoutes } from "./router/web-app-routes";

dotenv.config();
const dirname = url.fileURLToPath(new URL(".", import.meta.url));
const PORT = process.env.PORT || 8080;
const documentsWatchPath = path.resolve(path.join(dirname, "../mml-documents"), "*.html");

const { app } = enableWs(express());
app.enable("trust proxy");

// TODO - remove example
// This exampleEnforcingUserAuthenticator is an example of how to enforce user-level character customisation
const exampleEnforcingUserAuthenticator = new ExampleEnforcingUserAuthenticator({
  updateUserCharacter: (clientId, userData) => {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    userNetworkingServer.updateUserCharacter(clientId, userData);
  },
});

// Specify the avatar to use here:
const characterDescription: CharacterDescription = {
  // Option 1 (Default) - Use a GLB file directly
  meshFileUrl: "/assets/models/bot.glb", // This is just an address of a GLB file
  // Option 2 - Use an MML Character from a URL
  // mmlCharacterUrl: "https://...",
  // Option 3 - Use an MML Character from a string
  // mmlCharacterString: `
  // <m-character src="/assets/models/bot.glb">
  //   <m-model src="/assets/models/hat.glb"
  //     socket="head"
  //     x="0.03" y="0" z="0.0"
  //     sx="1.03" sy="1.03" sz="1.03"
  //     rz="-90"
  //   ></m-model>
  // </m-character>
  // `,
};
const userAuthenticator = new BasicUserAuthenticator(characterDescription, {
  /*
   This option allows sessions that are reconnecting from a previous run of the server to connect even if the present a
   session token that was not generated by this run of the server.

   This is useful for development, but in deployed usage, it is recommended to set this to false.
  */
  devAllowUnrecognizedSessions: true,
});

const DOLBY_APP_KEY = process.env.DOLBY_APP_KEY ?? "";
const DOLBY_APP_SECRET = process.env.DOLBY_APP_SECRET ?? "";
let apiTokenPromise: Promise<jwtToken.JwtToken>;

const fetchApiToken = (): Promise<jwtToken.JwtToken> => {
  if (DOLBY_APP_KEY && DOLBY_APP_SECRET) {
    const apiAccessToken = dolbyio.authentication.getApiAccessToken(
      DOLBY_APP_KEY,
      DOLBY_APP_SECRET,
      600,
      ["comms:client_access_token:create"],
    );
    return apiAccessToken;
  }
  throw new Error("Audio service not configured");
};

const fetchAccessToken = (apiToken: jwtToken.JwtToken, id: string) => {
  const accessToken = dolbyio.communications.authentication.getClientAccessTokenV2({
    accessToken: apiToken,
    externalId: id,
    sessionScope: ["conf:create", "notifications:set"],
  });
  return accessToken;
};

if (DOLBY_APP_KEY && DOLBY_APP_SECRET) {
  apiTokenPromise = fetchApiToken();
}

if (process.env.PASS) {
  app.use("/voice-token/:id", authMiddleware(process.env.PASS));
}

app.get("/voice-token/:id", async (req, res) => {
  try {
    if (!apiTokenPromise) {
      res.status(501).json({ error: "Audio service not configured" });
      return;
    }

    const { id } = req.params;
    if (!id) {
      res.status(400).json({ error: "id is required" });
      return;
    }

    let apiToken = await apiTokenPromise;

    try {
      const accessToken = await fetchAccessToken(apiToken, id);
      res.json({ accessToken: accessToken.access_token });
    } catch (err) {
      if (typeof err === "string" && err.includes("Expired or invalid token")) {
        try {
          console.log("Token is invalid or expired. Fetching a new one");
          apiTokenPromise = fetchApiToken();
          apiToken = await apiTokenPromise;
          const accessToken = await fetchAccessToken(apiToken, id);
          res.json({ accessToken: accessToken.access_token });
        } catch (error) {
          console.error(`Error re-fetching for a valid token: ${error}`);
        }
      } else {
        throw err;
      }
    }
  } catch (err) {
    console.error(`error: ${err}`);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

const mmlDocumentsServer = new MMLDocumentsServer(documentsWatchPath);

// Handle example document sockets
app.ws(`/mml-documents/:filename`, (ws: WebSocket, req: express.Request) => {
  const { filename } = req.params;
  mmlDocumentsServer.handle(filename, ws);
});

// Serve assets with CORS allowing all origins
app.use("/assets/", cors(), express.static(path.resolve(dirname, "../../assets/")));

const chatNetworkingServer = new ChatNetworkingServer({
  getChatUserIdentity: (sessionToken: string) => {
    return userAuthenticator.getClientIdForSessionToken(sessionToken);
  },
});
app.ws("/chat-network", (ws) => {
  chatNetworkingServer.connectClient(ws);
});

const userNetworkingServer = new UserNetworkingServer({
  onClientConnect: (
    clientId: number,
    sessionToken: string,
    userIdentityPresentedOnConnection?: UserIdentity,
  ): UserData | null => {
    return userAuthenticator.onClientConnect(
      clientId,
      sessionToken,
      userIdentityPresentedOnConnection,
    );
  },
  onClientUserIdentityUpdate: (clientId: number, userIdentity: UserIdentity): UserData | null => {
    // Called whenever a user connects or updates their character/identity
    return userAuthenticator.onClientUserIdentityUpdate(clientId, userIdentity);
  },
  onClientDisconnect: (clientId: number): void => {
    userAuthenticator.onClientDisconnect(clientId);
    // Disconnect the corresponding chat client to avoid later conflicts of client ids
    chatNetworkingServer.disconnectClientId(clientId);
  },
});

app.ws("/network", (ws) => {
  userNetworkingServer.connectClient(ws);
});
// Serve the web-client app (including development mode)
addWebAppRoutes(app, {
  generateAuthorizedSessionToken(req: express.Request): string | null {
    return userAuthenticator.generateAuthorizedSessionToken(req);
  },
});

// Serve the local-multi-web-client app
addLocalMultiWebAppRoutes(app);

// Start listening
console.log("Listening on port", PORT);
app.listen(PORT);
