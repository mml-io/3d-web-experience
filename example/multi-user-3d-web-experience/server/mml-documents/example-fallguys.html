<m-group id="fall-guys-group" y="300">
  <m-group id="helis-group"></m-group>
  <m-group id="rotate-group" ry="90" x="0.7"></m-group>
  <m-group id="hammers-group" y="-3.5"></m-group>
  <m-group id="sine-group"></m-group>
  <m-group id="axe-group"></m-group>
  <m-group id="travelator" ry="180" z="142"></m-group>
</m-group>

<script>
  const fallGuysGroup = document.getElementById("fall-guys-group");
  const helisGroup = document.getElementById("helis-group");
  const rotateGroup = document.getElementById("rotate-group");
  const hammersGroup = document.getElementById("hammers-group");
  const sineGroup = document.getElementById("sine-group");
  const axeGroup = document.getElementById("axe-group");
  const travelatorGroup = document.getElementById("travelator");

  const hammersLeft = document.createElement("m-group");
  const hammersRight = document.createElement("m-group");

  const usersInRange = new Map();

  const gameYPos = 90;
  const gameZPos = 300;

  const width = 10;
  const height = 0.1;
  const depth = 308;
  const numberOfPlatforms = 12;
  const movementDuration = 12;
  const stepDepth = depth / numberOfPlatforms;

  function randomIntPoN(val) {
    val = Math.abs(val);
    return Math.floor(Math.random() * (val * 2 + 1)) - val;
  }

  function createCube(
    x,
    y,
    z,
    width,
    height,
    depth,
    opacity,
    color = "#aaaaaa",
    castShadows = true,
  ) {
    const cube = document.createElement("m-cube");
    cube.setAttribute("x", x);
    cube.setAttribute("y", y);
    cube.setAttribute("z", z);
    cube.setAttribute("width", width);
    cube.setAttribute("depth", depth);
    cube.setAttribute("height", height);
    cube.setAttribute("color", color);
    cube.setAttribute("opacity", opacity);
    cube.setAttribute("cast-shadows", castShadows);
    return cube;
  }

  function createCylinder(x, y, z, radius, height, opacity, color = "#aaaaaa") {
    const cube = document.createElement("m-cylinder");
    cube.setAttribute("x", x);
    cube.setAttribute("y", y);
    cube.setAttribute("z", z);
    cube.setAttribute("radius", radius);
    cube.setAttribute("height", height);
    cube.setAttribute("color", color);
    cube.setAttribute("opacity", opacity);
    return cube;
  }

  function animate(element, attr, start, end, duration, easing, loop = false) {
    const anim = document.createElement("m-attr-anim");
    anim.setAttribute("attr", attr);
    anim.setAttribute("start", start);
    anim.setAttribute("end", end);
    anim.setAttribute("start-time", document.timeline.currentTime);
    anim.setAttribute("end-time", document.timeline.currentTime + duration);
    anim.setAttribute("duration", duration);
    anim.setAttribute("easing", easing);
    anim.setAttribute("loop", loop);
    element.appendChild(anim);
    setTimeout(() => {
      element.setAttribute(attr, end);
      element.removeChild(anim);
    }, duration);
    return anim;
  }

  function createPingPongAnim(attr, start, end, startTime, duration, pingPongDelay, easing) {
    const anim = document.createElement("m-attr-anim");
    anim.setAttribute("attr", attr);
    anim.setAttribute("start", start);
    anim.setAttribute("end", end);
    anim.setAttribute("start-time", startTime);
    anim.setAttribute("duration", duration);
    anim.setAttribute("ping-pong", true);
    anim.setAttribute("ping-pong-delay", pingPongDelay);
    if (easing) anim.setAttribute("easing", easing);
    return anim;
  }

  function createSequence(element, sequence, easing, duration, pauses, loop = false) {
    const timeAction = (cb, delay) => setTimeout(() => cb(), delay);

    const animSequence = [];
    for (let i = 0; i < sequence.length; i++) {
      const seq = sequence[i];
      if (Array.isArray(seq)) {
        const subSeqArr = [];
        for (let j = 0; j < seq.length; j++) {
          const subSeq = seq[j];
          subSeqArr.push(() =>
            animate(element, subSeq.attr, subSeq.start, subSeq.end, duration, easing),
          );
        }
        animSequence.push(subSeqArr);
      } else {
        animSequence.push(() =>
          animate(element, sequence[i].attr, sequence[i].start, sequence[i].end, duration, easing),
        );
      }
    }

    const seqSize = animSequence.length;
    const seqDuration = seqSize * duration + seqSize * pauses;

    const playSeq = () => {
      for (let i = 0; i < seqSize; i++) {
        if (typeof animSequence[i] === "function") {
          timeAction(animSequence[i], duration * i + pauses * i);
        } else if (Array.isArray(animSequence[i])) {
          for (let j = 0; j < animSequence[i].length; j++) {
            timeAction(animSequence[i][j], duration * i + pauses * i);
          }
        }
      }
    };

    playSeq();
    if (loop === true) {
      setInterval(() => playSeq(), seqDuration);
    } else {
      setTimeout(() => element.remove() + 100, seqDuration);
    }
  }

  function createTransporter(x, y, z, targetY) {
    const size = 1.5;
    const thickness = 0.03;
    const transporter = createCylinder(x, y, z, size, thickness, 1.0, "#4D96ED");

    const coinFlip = Math.random() < 0.5 ? -1 : 1;

    const firstX = (-10 - Math.random() * 20) * coinFlip;
    const firstY = targetY - 15 + Math.random() * 20;
    const firstZ = -70 + randomIntPoN(10);

    const secondX = Math.random() * 10 * coinFlip;
    const secondY = targetY + 20 + Math.random() * 10;
    const secondZ = -30 + Math.random() * 20;

    const finalX = randomIntPoN(12);
    const finalZ = randomIntPoN(10);

    const transportSequence = [
      [
        { attr: "x", start: x, end: firstX },
        { attr: "y", start: y, end: firstY },
        { attr: "z", start: z, end: firstZ },
      ],
      [
        { attr: "x", start: firstX, end: secondX },
        { attr: "y", start: firstY, end: secondY },
        { attr: "z", start: firstZ, end: secondZ },
      ],
      [
        { attr: "x", start: secondX, end: finalX },
        { attr: "y", start: secondY, end: targetY - thickness },
        { attr: "z", start: secondZ, end: finalZ },
      ],
    ];
    createSequence(transporter, transportSequence, "easeInOutQuart", 1500, 0, false);
    fallGuysGroup.appendChild(transporter);
  }

  function createRespawner(targetY) {
    const respawnerWidth = 9900;
    const respawnerHeight = 0.2;
    const respawnerDepth = 9900;
    const usersColliding = new Set();
    const respawner = createCube(
      0,
      0,
      0,
      respawnerWidth,
      respawnerHeight,
      respawnerDepth,
      0,
      "#ffffff",
      false,
    );
    respawner.setAttribute("collision-interval", 100);
    respawner.addEventListener("collisionstart", (e) => {
      if (!usersColliding.has(e.detail.connectionId)) {
        usersColliding.add(e.detail.connectionId);
        const { x, y, z } = e.detail.position;
        const worldX = x * respawnerWidth;
        const worldY = y * respawnerHeight - respawnerHeight * 1.9;
        const worldZ = z * respawnerDepth;
        const height = respawnerHeight / 2;
        createTransporter(worldX, worldY, worldZ, targetY);
      }
    });
    respawner.addEventListener("collisionend", (e) => {
      if (usersColliding.has(e.detail.connectionId)) {
        usersColliding.delete(e.detail.connectionId);
      }
    });
    respawner.addEventListener("collisionmove", (e) => {
      if (!usersColliding.has(e.detail.connectionId)) {
        usersColliding.add(e.detail.connectionId);
        const { x, y, z } = e.detail.position;
        const worldX = x * respawnerWidth;
        const worldY = y * respawnerHeight - respawnerHeight * 1.9;
        const worldZ = z * respawnerDepth;
        const height = respawnerHeight / 2;
        createTransporter(worldX, worldY, worldZ);
      }
    });
    window.addEventListener("disconnected", (e) => {
      if (usersColliding.has(e.detail.connectionId)) {
        usersColliding.delete(e.detail.connectionId);
      }
      if (usersInRange.has(e.detail.connectionId)) {
        usersInRange.delete(e.detail.connectionId);
      }
    });

    fallGuysGroup.appendChild(respawner);
  }

  function createStageFrame(url, x, y, z) {
    const frame = document.createElement("m-frame");
    frame.setAttribute("src", url);
    frame.setAttribute("x", x);
    frame.setAttribute("y", y);
    frame.setAttribute("z", z);
    fallGuysGroup.appendChild(frame);
  }

  function createStart(yPos) {
    const start = document.createElement("m-model");
    start.setAttribute(
      "src",
      "https://mmlstorage.com/7cc228329dcaf3a76091da3b0d42501e05d65a0e9954f67b3d63c40cba4e8d0a",
    );
    start.setAttribute("x", 0);
    start.setAttribute("y", yPos);
    start.setAttribute("z", 0);

    let furthestZ = 0;

    const positionProbe = document.createElement("m-position-probe");
    positionProbe.setAttribute("interval", 333);
    positionProbe.setAttribute("range", 300);
    positionProbe.setAttribute("z", 250);
    positionProbe.setAttribute("debug", false);

    const gameMusic = document.createElement("m-audio");
    gameMusic.setAttribute(
      "src",
      "https://mmlstorage.com/f49a2f438482c15f073ef6ab1e30912856ff751bf8afdd7e4562fb0f016b328d",
    );
    gameMusic.setAttribute("loop", true);
    gameMusic.setAttribute("z", -14);
    gameMusic.setAttribute("y", 3);
    gameMusic.setAttribute("ry", 180);
    gameMusic.setAttribute("cone-angle", 90);
    gameMusic.setAttribute("cone-falloff-angle", 130);
    gameMusic.setAttribute("volume", 3);
    gameMusic.setAttribute("start-time", document.timeline.currentTime);
    gameMusic.setAttribute("debug", false);
    start.appendChild(gameMusic);

    positionProbe.addEventListener("positionenter", (e) => {
      const relativeZ = e.detail.elementRelative.position.z;
      usersInRange.set(e.detail.connectionId, relativeZ);
    });
    positionProbe.addEventListener("positionmove", (e) => {
      const relativeZ = e.detail.elementRelative.position.z;
      usersInRange.set(e.detail.connectionId, relativeZ);
    });
    positionProbe.addEventListener("positionleave", (e) => {
      if (usersInRange.has(e.detail.connectionId)) {
        usersInRange.delete(e.detail.connectionId);
      }
    });

    setInterval(() => {
      let max = -1000;
      usersInRange.forEach((user) => {
        if (user > max) max = user;
      });
      gameMusic.setAttribute("z", max + 260);
    }, 333);

    start.appendChild(positionProbe);
    fallGuysGroup.appendChild(start);
  }

  function createEnd(yPos, zPos) {
    const end = document.createElement("m-model");
    end.setAttribute(
      "src",
      "https://mmlstorage.com/123834da5b6b74838e5885fd1252b75c8b245a1fccb1f2af0b3d5cb3966fb026",
    );
    end.setAttribute("x", 0);
    end.setAttribute("y", yPos);
    end.setAttribute("z", zPos);
    end.setAttribute("ry", 180);
    fallGuysGroup.appendChild(end);
  }

  function spin(element, duration, clockWise = true) {
    const anim = document.createElement("m-attr-anim");
    anim.setAttribute("attr", "ry");
    anim.setAttribute("start", clockWise ? 0 : 360);
    anim.setAttribute("end", clockWise ? 360 : 0);
    anim.setAttribute("start-time", document.timeline.currentTime);
    anim.setAttribute("duration", duration);
    anim.setAttribute("loop", true);
    element.appendChild(anim);
    return anim;
  }

  function createHeli(left = false) {
    const heliGroup = document.createElement("m-group");
    const body = document.createElement("m-model");
    body.setAttribute(
      "src",
      "https://mmlstorage.com/5fc4d5b539ad59bb07bada315f8496a9560447fefb33a7050421ee548d6b9f91",
    );
    heliGroup.appendChild(body);

    const heliBlade = document.createElement("m-model");
    heliBlade.setAttribute(
      "src",
      "https://mmlstorage.com/6f6b9876c21a5102eb2b06f76d81bc1ed313257ce241346926e429b53811e431",
    );
    spin(heliBlade, 200, left);
    heliGroup.appendChild(heliBlade);

    return heliGroup;
  }

  function createSpinner(x, y, z, clockWise = true) {
    const spinner = document.createElement("m-model");
    spinner.setAttribute(
      "src",
      "https://mmlstorage.com/862d1a160feac58e73e2cc58426e5e97158d609de74c4fb1eb810a5563077a2c",
    );
    spinner.setAttribute("x", x);
    spinner.setAttribute("y", y);
    spinner.setAttribute("z", z);
    spinner.setAttribute("rx", clockWise ? 180 : 0);
    spinner.setAttribute("rz", clockWise ? 180 : 0);
    return spinner;
  }

  function createSpinnersInHexGrid(segmentOffset, y, width, depth, fullRotationTime) {
    const spinnerRadius = 3.4999;
    const spinnerDiameter = spinnerRadius * 2;
    const hexHeight = (spinnerDiameter * Math.sqrt(3)) / 2;
    const numSpinnersX = Math.floor(width / spinnerDiameter);
    const numSpinnersZ = Math.floor(depth / hexHeight);

    const totalWidth = numSpinnersX * spinnerDiameter + spinnerRadius;
    const totalDepth = numSpinnersZ * hexHeight;
    const halfTotalWidth = totalWidth / 2;
    const halfRadius = spinnerRadius / 2;

    for (let j = 0; j < numSpinnersZ; j++) {
      for (let i = 0; i < numSpinnersX; i++) {
        const ccw = (i + j) % 2 === 0;
        const xOffset = (j % 2) * spinnerRadius;
        const x = i * spinnerDiameter + xOffset - halfTotalWidth + halfRadius;
        const z = j * hexHeight - totalDepth / 2 + halfRadius;
        const spinner = createSpinner(x - segmentOffset, y, z, ccw);
        spin(spinner, fullRotationTime, true);
        rotateGroup.appendChild(spinner);
      }
    }
  }

  function createHelis(xPos, yPos) {
    const now = document.timeline.currentTime;
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 2; j++) {
        const heli = createHeli(j === 0);
        heli.setAttribute("x", j % 2 === 0 ? -14 : 14);
        heli.setAttribute("y", yPos);
        heli.setAttribute("z", -i * 8 + xPos);

        const heliAnim = createPingPongAnim("y", yPos, yPos + 0.5, now * -i * 300, 12000, 1200);
        heli.appendChild(heliAnim);
        helisGroup.appendChild(heli);
      }
    }
  }

  function rotateInZ(element, startTime, fullRevoTime, clockWise = true) {
    const anim = document.createElement("m-attr-anim");
    anim.setAttribute("attr", "rz");
    anim.setAttribute("start", clockWise ? 0 : 360);
    anim.setAttribute("end", clockWise ? 360 : 0);
    anim.setAttribute("start-time", startTime);
    anim.setAttribute("loop", true);
    anim.setAttribute("duration", fullRevoTime);
    element.appendChild(anim);
  }

  function createHammersBase() {
    const baseGroup = document.createElement("m-group");
    const base = document.createElement("m-model");
    base.setAttribute(
      "src",
      "https://mmlstorage.com/b7fc21d3f588de4895e298965bc4db143086d79cd51f42c981a8f7ef368420d8",
    );
    base.setAttribute("sx", 1);
    base.setAttribute("sy", 1);
    base.setAttribute("sz", 2);
    baseGroup.appendChild(base);

    for (let i = 0; i < 2; i++) {
      const edge = document.createElement("m-model");
      edge.setAttribute(
        "src",
        "https://mmlstorage.com/00bf1759b93a3d2870add4f8e4a8f0a5dc332617342e04038f66d93b1f6599b7",
      );
      edge.setAttribute("z", i % 3 === 0 ? 30 : -30);
      baseGroup.appendChild(edge);
    }
    return baseGroup;
  }

  function createHammer(z) {
    const hammer = document.createElement("m-model");
    hammer.setAttribute(
      "src",
      "https://mmlstorage.com/c6a1a498f7a79d8a8780ea634c31adcc0c5e0905910d34af367ef11565673366",
    );
    hammer.setAttribute("z", z);
    hammer.setAttribute("sx", 1);
    hammer.setAttribute("sy", 0.95);
    hammer.setAttribute("sz", 2.5);
    return hammer;
  }

  function createHammers(segmentOffset, yPos) {
    const now = document.timeline.currentTime;
    const hammersCount = 13;
    const hammersInitialOffset = -22.25;
    const hammersOffset = 3.75;
    const speedOffsetMult = 600;

    const baseLeft = createHammersBase();
    const baseRight = createHammersBase();
    hammersLeft.appendChild(baseLeft);
    hammersRight.appendChild(baseRight);

    for (let i = 0; i < hammersCount; i++) {
      const speedOffset = Math.random() * speedOffsetMult * (Math.random() < 0.5 ? -1 : 1);
      const hammer = createHammer(hammersInitialOffset + hammersOffset * i);
      rotateInZ(hammer, now - i * 300, 2100 + speedOffset, Math.random() < 0.5);
      hammersLeft.appendChild(hammer);
    }
    for (let i = 0; i < hammersCount; i++) {
      const speedOffset = Math.random() * speedOffsetMult * (Math.random() < 0.5 ? -1 : 1);
      const hammer = createHammer(hammersInitialOffset + hammersOffset * i);
      rotateInZ(hammer, now - i * 300, 2100 + speedOffset, Math.random() < 0.5);
      hammersRight.appendChild(hammer);
    }

    hammersLeft.setAttribute("x", 6);
    hammersLeft.setAttribute("y", yPos);
    hammersLeft.setAttribute("z", segmentOffset);
    hammersRight.setAttribute("x", -6);
    hammersRight.setAttribute("y", yPos);
    hammersRight.setAttribute("z", segmentOffset);
    hammersGroup.appendChild(hammersLeft);
    hammersGroup.appendChild(hammersRight);
  }

  function createHexagon(x, y, z) {
    const hexagon = document.createElement("m-model");
    hexagon.setAttribute(
      "src",
      "https://mmlstorage.com/7450bbca66beabba1351e28d591d12579b34bb07dc98addbc905e8fb77441e0a",
    );
    hexagon.setAttribute("x", x);
    hexagon.setAttribute("y", y);
    hexagon.setAttribute("z", z);
    return hexagon;
  }

  function createSinePlatforms(segmentOffset, yPos) {
    const now = document.timeline.currentTime;
    const totalPlatforms = 10;
    const sineTime = 10000;
    for (let i = 0; i < totalPlatforms; i++) {
      const hexPlatform = createHexagon(0, yPos, i * 11 + segmentOffset);
      if (i < totalPlatforms - 1) {
        const sineAnim = createPingPongAnim("x", -6, 6, now - i * 1000, sineTime, sineTime * 0.1);
        hexPlatform.appendChild(sineAnim);
        const yAnim = createPingPongAnim(
          "y",
          yPos,
          yPos - 0.5,
          now - i * 1000,
          sineTime * 0.5,
          sineAnim * 0.5 * 0.1,
        );
        hexPlatform.appendChild(yAnim);
      }
      sineGroup.appendChild(hexPlatform);
    }
  }

  function createAxesBase(segmentOffset, yPos) {
    const base = document.createElement("m-model");
    base.setAttribute(
      "src",
      "https://mmlstorage.com/868a5c396cea60affe16a4573ada83a2ebb698aa372414bbce98295e0bf455f2",
    );
    base.setAttribute("z", segmentOffset);
    base.setAttribute("y", yPos);
    axeGroup.appendChild(base);
  }

  function createAxe(yPos, zPos) {
    const axeGroup = document.createElement("m-group");

    const axeRod = document.createElement("m-model");
    axeRod.setAttribute(
      "src",
      "https://mmlstorage.com/a5b420cb56aa9d7f265472edc73d3dda92de63975d1f2bc5c962eb67786dadd4",
    );
    axeRod.setAttribute("collide", false);
    axeGroup.appendChild(axeRod);

    const axeBlade = document.createElement("m-model");
    axeBlade.setAttribute(
      "src",
      "https://mmlstorage.com/4783c199f52cebf8298882c6b18fa42045b918fa40b53ef899555b3d17115acc",
    );
    axeBlade.setAttribute("sz", 2);
    axeGroup.appendChild(axeBlade);

    axeGroup.setAttribute("z", zPos);
    axeGroup.setAttribute("y", yPos + 19.8);

    return axeGroup;
  }

  function createAxes(segmentOffset, yPos) {
    const now = document.timeline.currentTime;
    const totalAxes = 9;
    const axeSwingTime = 4000;
    const zOffset = -17;
    const space = 4.25;
    for (let i = 0; i < totalAxes; i++) {
      const axe = createAxe(yPos, segmentOffset + zOffset + i * space);
      const anim = createPingPongAnim(
        "rz",
        -45,
        45,
        now * -i * 3,
        axeSwingTime,
        axeSwingTime * 0.025,
        "easeInOutQuad",
      );
      axe.appendChild(anim);
      axeGroup.appendChild(axe);
    }
  }

  function createAxesSegment(segmentOffset, yPos) {
    createAxesBase(segmentOffset, yPos);
    createAxes(segmentOffset, yPos);
  }

  function createStaticStep(xPosition, yPosition, zPosition) {
    const step = document.createElement("m-cube");
    step.setAttribute("width", width + 0.1);
    step.setAttribute("height", height);
    step.setAttribute("depth", stepDepth * 1.3);
    step.setAttribute("x", xPosition);
    step.setAttribute("y", yPosition);
    step.setAttribute("z", zPosition);
    step.setAttribute("color", "#bbbbbb");
    return step;
  }

  function animateWithTime(element, attr, start, end, duration, startTime) {
    const anim = document.createElement("m-attr-anim");
    anim.setAttribute("attr", attr);
    anim.setAttribute("start", start);
    anim.setAttribute("end", end);
    anim.setAttribute("start-time", startTime);
    anim.setAttribute("duration", duration);
    anim.setAttribute("loop", true);
    element.appendChild(anim);
    return anim;
  }

  function createMovingSteps(xPosition, yPosition) {
    const startingStep = createStaticStep(xPosition, yPosition, -depth / 2 + stepDepth / 2);
    travelatorGroup.appendChild(startingStep);

    const endingStep = createStaticStep(xPosition, yPosition, depth / 2 - stepDepth / 2 - 0.1);
    travelatorGroup.appendChild(endingStep);

    const now = document.timeline.currentTime;
    for (let i = 0; i < numberOfPlatforms; i++) {
      const zPos = -depth / 2 + stepDepth / 2 + i * stepDepth;
      const hue = (360 / numberOfPlatforms) * i;
      const platform = document.createElement("m-cube");
      platform.setAttribute("width", width);
      platform.setAttribute("height", height);
      platform.setAttribute("depth", stepDepth);
      platform.setAttribute("x", xPosition);
      platform.setAttribute("y", yPosition - 0.02);
      platform.setAttribute("z", zPos);
      platform.setAttribute("color", `hsl(${hue}, 90%, 80%)`);
      const startTime = now - (movementDuration * 1000 * i) / (numberOfPlatforms - 1);
      animateWithTime(
        platform,
        "z",
        -depth / 2 + stepDepth / 2,
        depth / 2 - stepDepth / 2,
        movementDuration * 1000,
        startTime,
      );
      travelatorGroup.appendChild(platform);
    }
  }

  createMovingSteps(20, gameYPos - 0.05);

  createRespawner(gameYPos);
  createStart(gameYPos);
  createHelis(70, gameYPos);
  createHelis(140, gameYPos);
  createSpinnersInHexGrid(36.05, gameYPos, 42, 19, 2900);
  createHammers(98, gameYPos);
  createSinePlatforms(135, gameYPos);
  createAxesSegment(259, gameYPos);
  createEnd(gameYPos, 296.6);
</script>
