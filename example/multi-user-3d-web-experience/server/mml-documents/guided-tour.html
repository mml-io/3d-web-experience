<m-group id="progression-space"></m-group>
<script>
  const progressionSpace = document.getElementById("progression-space");

  const color = "#aaaaaa";
  const defaultColor = "#aaaaaa";
  const windowColor = "#000000";
  const windowOpacity = 0.75;
  const globalDebug = false;

  const roomsWidth = 35;
  const roomsDepth = 45;
  const roomsHeight = 21;
  const roomsThickness = 0.25;

  const spaceBetweenRooms = 8;
  const numberOfRooms = 6;

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function createWall(width, height, depth, angle, x, y, z, color) {
    const group = document.createElement("m-group");
    const wall = document.createElement("m-cube");
    wall.setAttribute("width", width - depth);
    wall.setAttribute("height", height + depth);
    wall.setAttribute("depth", depth);
    wall.setAttribute("y", height / 2);
    wall.setAttribute("color", color);
    group.appendChild(wall);
    group.setAttribute("ry", angle);
    group.setAttribute("x", x);
    group.setAttribute("y", y + depth);
    group.setAttribute("z", z);
    return group;
  }

  function createWallWithOpening(
    width,
    height,
    depth,
    openingWidth,
    openingHeight,
    angle,
    x,
    y,
    z,
    openingOffsetX = 0.5, // Horizontal offset from 0.0 (left) to 1.0 (right)
    openingOffsetY = 0.0, // Vertical offset from 0.0 (bottom) to 1.0 (top)
    color,
    hasWindowGlass = false,
    windowOpacity = 0.8,
    debug = false,
  ) {
    openingWidth += depth;
    height += depth / 2; // Adjust overall height for depth compensation
    openingHeight = Math.min(height, openingHeight);

    const group = document.createElement("m-group");
    const halfWidth = width / 2;
    const entranceHalfWidth = openingWidth / 2;

    const openingMinOffset = depth;
    const openingMaxOffsetX = width - depth - openingWidth;
    const openingMaxOffsetY = height - depth - openingHeight;

    const openingCenterX =
      -halfWidth +
      (openingMinOffset +
        openingOffsetX * (openingMaxOffsetX - openingMinOffset) +
        entranceHalfWidth);

    // Vertical opening positioning
    const openingBaseY = openingOffsetY * (height - openingHeight);

    // Calculate the widths of the left and right walls
    const leftWallWidth = openingCenterX - entranceHalfWidth + halfWidth - depth;
    const rightWallWidth = halfWidth - entranceHalfWidth - openingCenterX - depth;

    // Create the left wall
    const leftWall = document.createElement("m-cube");
    leftWall.setAttribute("width", leftWallWidth + depth);
    leftWall.setAttribute("height", height);
    leftWall.setAttribute("depth", depth);
    leftWall.setAttribute("x", -(halfWidth - leftWallWidth / 2 - depth));
    leftWall.setAttribute("y", height / 2);
    leftWall.setAttribute("color", color);

    // Create the right wall
    const rightWall = document.createElement("m-cube");
    rightWall.setAttribute("width", rightWallWidth + depth);
    rightWall.setAttribute("height", height);
    rightWall.setAttribute("depth", depth);
    rightWall.setAttribute("x", halfWidth - rightWallWidth / 2 - depth);
    rightWall.setAttribute("y", height / 2);
    rightWall.setAttribute("color", color);

    // Create the top wall if necessary
    let topWall = null;
    if (openingOffsetY < 1.0 && openingBaseY + openingHeight < height) {
      topWall = document.createElement("m-cube");
      topWall.setAttribute("width", openingWidth);
      topWall.setAttribute("height", height - (openingBaseY + openingHeight));
      topWall.setAttribute("depth", depth);
      topWall.setAttribute("x", openingCenterX);
      topWall.setAttribute(
        "y",
        openingBaseY + openingHeight + (height - (openingBaseY + openingHeight)) / 2,
      );
      topWall.setAttribute("color", color);
      group.appendChild(topWall);
    }

    // Create the bottom wall if necessary
    let bottomWall = null;
    if (openingOffsetY > -depth && openingBaseY > -depth) {
      bottomWall = document.createElement("m-cube");
      bottomWall.setAttribute("width", openingWidth - depth);
      bottomWall.setAttribute("height", openingBaseY + depth);
      bottomWall.setAttribute("depth", depth);
      bottomWall.setAttribute("x", openingCenterX);
      bottomWall.setAttribute("y", openingBaseY / 2 - depth / 2);
      bottomWall.setAttribute("color", debug === true ? "#ffaaaa" : color);
      group.appendChild(bottomWall);
    }

    if (hasWindowGlass) {
      const windowPane = document.createElement("m-cube");
      windowPane.setAttribute("width", openingWidth - depth);
      windowPane.setAttribute("height", openingHeight);
      windowPane.setAttribute("depth", depth);
      windowPane.setAttribute("x", openingCenterX);
      windowPane.setAttribute("y", openingBaseY + openingHeight / 2);
      windowPane.setAttribute("collide", true);
      windowPane.setAttribute("color", windowColor);
      windowPane.setAttribute("opacity", windowOpacity);
      windowPane.setAttribute("cast-shadows", false);
      group.appendChild(windowPane);
    }

    // Set the group's rotation and position
    group.setAttribute("ry", angle);
    group.setAttribute("x", x);
    group.setAttribute("y", y + depth);
    group.setAttribute("z", z);

    // Append the walls to the group
    group.appendChild(leftWall);
    group.appendChild(rightWall);

    const wallOpeningData = {
      width: openingWidth - depth,
      height: openingHeight,
      depth: depth,
      x: angle === 90 ? x : openingCenterX,
      y: openingBaseY, // + openingHeight / 2,
      z: angle === 90 ? -openingCenterX : z,
      meshGroup: group,
    };

    return wallOpeningData;
  }

  function createFloorOrCeiling(width, depth, x, y, z, height, color) {
    const floor = document.createElement("m-cube");
    floor.setAttribute("width", width - height);
    floor.setAttribute("depth", depth - height);
    floor.setAttribute("height", height);
    floor.setAttribute("x", x);
    floor.setAttribute("y", y + height / 2);
    floor.setAttribute("z", z);
    floor.setAttribute("color", color);
    return floor;
  }

  function createFloorOrCeilingWithOpening(
    width,
    depth,
    height,
    openingWidth,
    openingDepth,
    angle,
    x,
    y,
    z,
    openingOffsetX = 0.5,
    openingOffsetZ = 0.5,
    color,
    hasWindowGlass = false,
    windowOpacity = 0.8,
    debug = false,
  ) {
    const adjustedWidth = width - height;
    const adjustedDepth = depth - height;
    const group = document.createElement("m-group");

    // Calculate opening positions
    const openingCenterX = (adjustedWidth - openingWidth) * (openingOffsetX - 0.5);
    const openingCenterZ = (adjustedDepth - openingDepth) * (openingOffsetZ - 0.5);

    // Create the left part
    const leftPartWidth = adjustedWidth / 2 + openingCenterX - openingWidth / 2;
    if (leftPartWidth > 0) {
      const leftPart = document.createElement("m-cube");
      leftPart.setAttribute("width", leftPartWidth);
      leftPart.setAttribute("depth", adjustedDepth);
      leftPart.setAttribute("height", height);
      leftPart.setAttribute("x", -(adjustedWidth / 2 - leftPartWidth / 2));
      leftPart.setAttribute("y", height / 2);
      leftPart.setAttribute("z", 0);
      leftPart.setAttribute("color", debug ? "#aabbcc" : color);
      group.appendChild(leftPart);
    }

    // Create the right part
    const rightPartWidth = adjustedWidth / 2 - openingCenterX - openingWidth / 2;
    if (rightPartWidth > 0) {
      const rightPart = document.createElement("m-cube");
      rightPart.setAttribute("width", rightPartWidth);
      rightPart.setAttribute("depth", adjustedDepth);
      rightPart.setAttribute("height", height);
      rightPart.setAttribute("x", adjustedWidth / 2 - rightPartWidth / 2);
      rightPart.setAttribute("y", height / 2);
      rightPart.setAttribute("z", 0);
      rightPart.setAttribute("color", debug ? "#ccbbaa" : color);
      group.appendChild(rightPart);
    }

    // Create the front part
    const frontPartDepth = adjustedDepth / 2 + openingCenterZ - openingDepth / 2;
    if (frontPartDepth > 0) {
      const frontPart = document.createElement("m-cube");
      frontPart.setAttribute("width", openingWidth);
      frontPart.setAttribute("depth", frontPartDepth);
      frontPart.setAttribute("height", height);
      frontPart.setAttribute("x", openingCenterX);
      frontPart.setAttribute("y", height / 2);
      frontPart.setAttribute("z", -(adjustedDepth / 2 - frontPartDepth / 2));
      frontPart.setAttribute("color", debug ? "#ffffaa" : color);
      group.appendChild(frontPart);
    }

    // Create the back part
    const backPartDepth = adjustedDepth / 2 - openingCenterZ - openingDepth / 2;
    if (backPartDepth > 0) {
      const backPart = document.createElement("m-cube");
      backPart.setAttribute("width", openingWidth);
      backPart.setAttribute("depth", backPartDepth);
      backPart.setAttribute("height", height);
      backPart.setAttribute("x", openingCenterX);
      backPart.setAttribute("y", height / 2);
      backPart.setAttribute("z", adjustedDepth / 2 - backPartDepth / 2);
      backPart.setAttribute("color", debug ? "#ffaaaa" : color);
      group.appendChild(backPart);
    }

    if (hasWindowGlass) {
      const windowPane = document.createElement("m-cube");
      windowPane.setAttribute("width", openingWidth);
      windowPane.setAttribute("depth", openingDepth);
      windowPane.setAttribute("height", height);
      windowPane.setAttribute("x", openingCenterX);
      windowPane.setAttribute("y", height / 2);
      windowPane.setAttribute("z", openingCenterZ);
      windowPane.setAttribute("collide", true);
      windowPane.setAttribute("color", "#000000");
      windowPane.setAttribute("opacity", windowOpacity);
      windowPane.setAttribute("cast-shadows", false);
      group.appendChild(windowPane);
    }

    // Set the group's rotation and position
    group.setAttribute("ry", angle);
    group.setAttribute("x", x);
    group.setAttribute("y", y);
    group.setAttribute("z", z);

    return group;
  }

  function createRoom(
    width,
    depth,
    height,
    doors,
    windows,
    x,
    y,
    z,
    thickness,
    color,
    hasCeiling = true,
    debug = false,
  ) {
    const room = document.createElement("m-group");
    const halfWidth = width / 2;
    const halfDepth = depth / 2;

    const floor = createFloorOrCeiling(width, depth, 0, 0, -halfDepth, thickness, color);
    room.appendChild(floor);

    if (hasCeiling) {
      const ceiling = createFloorOrCeilingWithOpening(
        width,
        depth,
        thickness,
        width - 4,
        depth - 4,
        0, // angle
        0, // x
        height + thickness * 1.5, // y
        -halfDepth, // z
        0.5,
        0.5,
        color,
        windowOpacity,
        0.8,
        debug,
      );
      room.appendChild(ceiling);
    }

    const doorsData = {};

    // Helper function to create walls
    function addWallWithOrientation(direction, config) {
      const hasWindowGlass = config.hasOwnProperty("glass") ? config.glass : false;
      const posX = direction === "PX" ? halfWidth : direction === "NX" ? -halfWidth : 0;
      const posZ = direction === "NZ" ? -depth : direction === "PZ" ? 0 : 0;
      const wallAngle = direction === "PX" || direction === "NX" ? 90 : 0;

      const wallData = createWallWithOpening(
        direction === "PX" || direction === "NX" ? depth : width,
        height,
        thickness,
        config.width,
        config.height,
        wallAngle,
        posX,
        0,
        direction === "PX" || direction === "NX" ? -halfDepth : posZ,
        config.offsetX,
        config.offsetY,
        color,
        hasWindowGlass,
        windowOpacity,
        debug,
      );

      if (direction.includes("Z")) {
        wallData.z += halfDepth;
      }

      if (!hasWindowGlass) {
        doorsData[direction] = {
          width: wallData.width,
          height: wallData.height,
          depth: wallData.depth,
          x: wallData.x + x,
          y: wallData.y + y,
          z: wallData.z + z,
        };
      }

      room.appendChild(wallData.meshGroup);
    }

    // Process each wall for doors and windows
    ["PX", "NX", "PZ", "NZ"].forEach((side) => {
      if (doors[side]) {
        addWallWithOrientation(side, { ...doors[side], glass: false });
      } else if (windows[side]) {
        addWallWithOrientation(side, { ...windows[side], glass: true });
      } else {
        // Create a regular wall if no door or window is specified
        const posX = side === "PX" ? halfWidth : side === "NX" ? -halfWidth : 0;
        const posZ = side === "NZ" ? -depth : side === "PZ" ? 0 : 0;
        room.appendChild(
          createWall(
            side === "PX" || side === "NX" ? depth : width,
            height,
            thickness,
            side === "PX" || side === "NX" ? 90 : 0,
            posX,
            0,
            side === "PX" || side === "NX" ? -halfDepth : posZ,
            color,
          ),
        );
      }
    });

    // Position the entire room
    room.setAttribute("x", x);
    room.setAttribute("y", y);
    room.setAttribute("z", z + halfDepth);

    const roomPX = x + halfWidth;
    const roomNX = x - halfWidth;
    const roomPZ = z + halfDepth;
    const roomNZ = z - halfDepth;
    const roomNY = y;
    const roomPY = y + height + thickness + thickness * 1.5;

    const roomData = {
      bounds: {
        NX: roomNX,
        PX: roomPX,
        NY: roomNY,
        PY: roomPY,
        NZ: roomNZ,
        PZ: roomPZ,
      },
      size: {
        width: roomPX - roomNX,
        height: roomPY - roomNY,
        depth: roomPZ - roomNZ,
      },
      position: {
        x: x,
        y: y,
        z: z + halfDepth,
      },
      doors: doorsData,
      meshGroup: room,
    };

    return roomData;
  }

  function createSignLabel(content, width, height, x, y, z, ry, fontSize = 24) {
    const label = document.createElement("m-label");
    label.setAttribute("padding", 0);
    label.setAttribute("alignment", "center");
    label.setAttribute("color", color);
    label.setAttribute("font-size", fontSize);
    label.setAttribute("content", content);
    label.setAttribute("width", width);
    label.setAttribute("height", height);
    label.setAttribute("x", x);
    label.setAttribute("y", y);
    label.setAttribute("z", z);
    label.setAttribute("ry", ry);
    return label;
  }

  function createLoadingFrame(frameUrl, x, y, z, minX, maxX, minY, maxY, minZ, maxZ) {
    const frame = document.createElement("m-frame");
    frame.setAttribute("x", x);
    frame.setAttribute("y", y);
    frame.setAttribute("z", z);
    frame.setAttribute("src", frameUrl);
    frame.setAttribute("min-x", minX);
    frame.setAttribute("max-x", maxX);
    frame.setAttribute("min-y", minY);
    frame.setAttribute("max-y", maxY);
    frame.setAttribute("min-z", minZ);
    frame.setAttribute("max-z", maxZ);
    frame.setAttribute("load-range", spaceBetweenRooms + roomsThickness * 4);
    frame.setAttribute("unload-range", roomsThickness);
    frame.setAttribute("debug", false);
    return frame;
  }

  function createFrame(frameUrl, x, y, z) {
    const frame = document.createElement("m-frame");
    frame.setAttribute("x", x);
    frame.setAttribute("y", y);
    frame.setAttribute("z", z);
    frame.setAttribute("src", frameUrl);
    return frame;
  }

  function setBoundingFrame(frame, x, y, z, minX, maxX, minY, maxY, minZ, maxZ) {
    frame.setAttribute("x", x);
    frame.setAttribute("y", y);
    frame.setAttribute("z", z);
    frame.setAttribute("min-x", minX);
    frame.setAttribute("max-x", maxX);
    frame.setAttribute("min-y", minY);
    frame.setAttribute("max-y", maxY);
    frame.setAttribute("min-z", minZ);
    frame.setAttribute("max-z", maxZ);
    frame.setAttribute("debug", false);
    return frame;
  }

  function animate(element, attr, start, end, duration) {
    const anim = document.createElement("m-attr-anim");
    anim.setAttribute("attr", attr);
    anim.setAttribute("start", start);
    anim.setAttribute("end", end);
    anim.setAttribute("start-time", document.timeline.currentTime);
    anim.setAttribute("duration", duration);
    anim.setAttribute("loop", true);
    element.appendChild(anim);
    return anim;
  }

  function createExternalElement(index, zPos) {
    let externalElement = null;
    switch (index) {
      case 0: {
        externalElement = createFrame("wss:///mml-documents/example-mml-logo.html", 10, 0, zPos);
        progressionSpace.appendChild(externalElement);
        break;
      }
      case 1: {
        externalElement = createFrame("wss:///mml-documents/example-duck.html", 10, 0, zPos);
        progressionSpace.appendChild(externalElement);
        break;
      }
      case 2: {
        externalElement = createFrame(
          "wss:///mml-documents/example-cinema-screen.html",
          10,
          0,
          zPos,
        );
        progressionSpace.appendChild(externalElement);
        break;
      }
      case 3: {
        externalElement = createFrame(
          "wss:///mml-documents/example-earth-info-api.html",
          10,
          0,
          zPos,
        );
        progressionSpace.appendChild(externalElement);
        break;
      }
      default:
        break;
    }
  }

  function createProgression() {
    for (let i = 0; i < numberOfRooms; i++) {
      const zPos = 14 + roomsDepth * i + spaceBetweenRooms * i;
      const exampleXPos = roomsWidth / 2;

      createExternalElement(i, zPos);

      // create the room ======================================================
      const roomModel = document.createElement("m-model");
      roomModel.setAttribute("src", "/assets/playground/building_module_bright_2.glb");
      roomModel.setAttribute("z", zPos);
      progressionSpace.appendChild(roomModel);

      const window = document.createElement("m-cube");
      window.setAttribute("color", "#001122");
      window.setAttribute("depth", 41.5);
      window.setAttribute("height", 17);
      window.setAttribute("width", 0.3);
      window.setAttribute("opacity", 0.4);
      window.setAttribute("x", 17.6);
      window.setAttribute("y", 10.2);
      window.setAttribute("z", zPos + 0.1);
      window.setAttribute("cast-shadows", false);
      progressionSpace.appendChild(window);

      // create the curves for the passages between rooms (loading) ===========
      if (i < numberOfRooms - 1) {
        const hallway = document.createElement("m-model");
        hallway.setAttribute("src", "/assets/playground/hallway_backdoor.glb");
        hallway.setAttribute("z", zPos + roomsDepth / 2 + 4.2);
        hallway.setAttribute("x", 0.015);
        hallway.setAttribute("y", 0.015);
        progressionSpace.appendChild(hallway);

        const travelatorPZ = document.createElement("m-frame");
        travelatorPZ.setAttribute("src", "wss:///mml-documents/example-travelator.html");
        travelatorPZ.setAttribute("ry", 180);
        travelatorPZ.setAttribute("x", -roomsWidth + 3);
        travelatorPZ.setAttribute("z", zPos + 10);
        progressionSpace.appendChild(travelatorPZ);

        const travelatorNZ = document.createElement("m-frame");
        travelatorNZ.setAttribute("src", "wss:///mml-documents/example-travelator.html");
        travelatorNZ.setAttribute("ry", 0);
        travelatorNZ.setAttribute("x", -roomsWidth + 10);
        travelatorNZ.setAttribute("z", zPos + 10);
        progressionSpace.appendChild(travelatorNZ);
      }

      const frameURL = `wss:///mml-documents/z-room-${i}.html`;
      const minX = -roomsWidth;
      const maxX = roomsWidth;
      const minY = -roomsHeight / 2;
      const maxY = roomsHeight + roomsThickness;
      const minZ = -roomsDepth / 2 - spaceBetweenRooms / 2;
      const maxZ = roomsDepth / 2 + spaceBetweenRooms / 2;

      let roomFrame = null;
      if (i === 4) {
        roomFrame = createFrame(frameURL, 0, 0, zPos);
      } else {
        roomFrame = createLoadingFrame(
          frameURL, // frameURL
          0, // x
          0, // y
          zPos, // z
          minX, // minX
          maxX,
          minY,
          maxY,
          minZ,
          maxZ,
        );
      }

      progressionSpace.appendChild(roomFrame);

      const debugToggle = document.createElement("m-label");
      debugToggle.setAttribute("x", roomsWidth / 2 + roomsThickness / 2 + 0.01);
      debugToggle.setAttribute("y", 0.15);
      debugToggle.setAttribute("z", zPos);
      debugToggle.setAttribute("content", "debug bounds");
      debugToggle.setAttribute("padding", 0);
      debugToggle.setAttribute("alignment", "center");
      debugToggle.setAttribute("width", 2);
      debugToggle.setAttribute("height", 0.3);
      debugToggle.setAttribute("color", "#888888");
      debugToggle.setAttribute("ry", 90);

      debugToggle.addEventListener("click", () => {
        const debugOn = roomFrame.getAttribute("class") === "debug-on";
        if (debugOn) {
          roomFrame.setAttribute("class", "debug-off");
          roomFrame.setAttribute("debug", false);
        } else {
          roomFrame.setAttribute("class", "debug-on");
          roomFrame.setAttribute("debug", true);
        }
      });
      progressionSpace.appendChild(debugToggle);

      const automaticDoor = document.createElement("m-frame");
      automaticDoor.setAttribute("src", `wss:///mml-documents/z-travelator-door-${i}.html`);
      automaticDoor.setAttribute("x", -roomsWidth / 2);
      automaticDoor.setAttribute("z", zPos - 17.6);
      progressionSpace.appendChild(automaticDoor);

      // create the travelator shortcut labels
      const nxExitPos = zPos - roomsDepth / 2 + 2.5 + roomsDepth * 0.1 - roomsThickness - 2;
      const travelatorExitLabel = createSignLabel(
        "shortcut to travellators",
        2,
        0.6,
        -roomsWidth / 2 + 0.126,
        6.6,
        nxExitPos,
        90,
      );
      progressionSpace.appendChild(travelatorExitLabel);
    }

    const travelatorCorridorDepth =
      roomsDepth * numberOfRooms + spaceBetweenRooms * (numberOfRooms - 1) - roomsThickness;
    const travelatorCorridorWidth = 21;

    const corridor = createRoom(
      travelatorCorridorWidth,
      travelatorCorridorDepth,
      roomsHeight / 2,
      {
        PX: {
          width: travelatorCorridorDepth,
          height: 6,
          offsetX: 0.9,
          offsetY: 0.0,
        },
      },
      {
        NX: {
          width: travelatorCorridorDepth - roomsThickness * 4,
          height: roomsHeight / 2 - roomsThickness,
          offsetX: 0.5,
          offsetY: 0.0,
        },
        NZ: {
          width: travelatorCorridorWidth - roomsThickness * 4,
          height: roomsHeight / 2 - roomsThickness,
          offsetX: 0.5,
          offsetY: 0.0,
        },
        PZ: {
          width: travelatorCorridorWidth - roomsThickness * 4,
          height: roomsHeight / 2 - roomsThickness,
          offsetX: 0.5,
          offsetY: 0.0,
        },
      },
      -roomsWidth / 2 - travelatorCorridorWidth / 2 - 0.03,
      -roomsThickness + 0.03,
      travelatorCorridorDepth / 2 - 8.55,
      roomsThickness,
      defaultColor,
      true,
    );
    progressionSpace.appendChild(corridor.meshGroup);
  }

  const dunes = document.createElement("m-model");
  dunes.setAttribute("src", "/assets/playground/sanddunes.glb");
  dunes.setAttribute("sx", "2");
  dunes.setAttribute("sy", "2");
  dunes.setAttribute("sz", "2");
  dunes.setAttribute("y", "-10");
  progressionSpace.appendChild(dunes);

  createProgression();
</script>
