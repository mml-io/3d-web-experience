<m-group id="sequencer-group" y="2"></m-group>

<script>
  const sequencerGroup = document.getElementById("sequencer-group");

  const channels = new Map();
  const animations = new Set();

  const bars = 16;
  const instruments = 3;
  const minBPM = 60;
  const maxBPM = 360;

  const buttonsGap = 0.1;
  const buttonSize = 0.5;

  const offSatLight = "20%, 40%";
  const onSatLight = "100%, 80%";

  let intervalId = null;
  let initialBPM = 120;
  let bpmStep = 5;
  let currentBar = 0;
  let bpmDisplay = null;

  function createLabel(width, height, color, fontColor, x = 0, y = 0, z = 0, initialContent) {
    const label = document.createElement("m-label");
    label.setAttribute("content", initialContent);
    label.setAttribute("padding", 0);
    label.setAttribute("alignment", "center");
    label.setAttribute("width", width);
    label.setAttribute("height", height);
    label.setAttribute("color", color);
    label.setAttribute("font-color", fontColor);
    label.setAttribute("x", x);
    label.setAttribute("y", y);
    label.setAttribute("z", z);
    return label;
  }

  function createCube(width, height, depth, color, x = 0, y = 0, z = 0) {
    const cube = document.createElement("m-cube");
    cube.setAttribute("width", width);
    cube.setAttribute("height", height);
    cube.setAttribute("depth", depth);
    cube.setAttribute("color", color);
    cube.setAttribute("x", x);
    cube.setAttribute("y", y);
    cube.setAttribute("z", z);
    return cube;
  }

  function bpmToMS(bpm) {
    return 60000 / bpm;
  }

  function createAnim(attr, start, end, startTime, duration, pingPongDelay) {
    const anim = document.createElement("m-attr-anim");
    anim.setAttribute("attr", attr);
    anim.setAttribute("start", start);
    anim.setAttribute("end", end);
    anim.setAttribute("start-time", startTime);
    anim.setAttribute("duration", duration);
    anim.setAttribute("ping-pong", true);
    anim.setAttribute("ping-pong-delay", pingPongDelay);
    return anim;
  }

  function animateBorders(bpm) {
    if (animations.size > 0) {
      animations.forEach((anim) => anim.remove());
      animations.clear();
    }
    const beatDuration = bpmToMS(bpm);
    const now = document.timeline.currentTime - beatDuration * bars;
    const posStart = buttonSize * 0.1 + 0.1 - 10;
    const posEnd = buttonSize * 0.1 + 0.1;
    channels.forEach((channel) => {
      const barsAmount = channel.length;
      for (let i = 0; i < bars; i++) {
        const anim = createAnim(
          "z",
          posStart,
          posEnd,
          now + i * beatDuration,
          beatDuration * bars,
          beatDuration,
        );
        animations.add(anim);
        channel[i].borderMesh.appendChild(anim);
      }
    });
  }

  function turnButtonLedOn(button) {
    button.setAttribute("class", "on");
    const color = button.getAttribute("color");
    const hue = parseInt(color.replace("hsl(", "").split(",")[0]);
    const newColor = `hsl(${hue}, ${onSatLight})`;
    button.setAttribute("color", newColor);
  }

  function turnButtonLedOff(button) {
    button.setAttribute("class", "off");
    const color = button.getAttribute("color");
    const hue = parseInt(color.replace("hsl(", "").split(",")[0]);
    const newColor = `hsl(${hue}, ${offSatLight})`;
    button.setAttribute("color", newColor);
  }

  function toggleButtonLed(button) {
    const on = button.getAttribute("class");
    if (on === "on") {
      turnButtonLedOff(button);
    } else {
      turnButtonLedOn(button);
    }
  }

  function turnBorderOn(border) {
    border.setAttribute("color", "#ffffff");
  }

  function turnBorderOff(border) {
    border.setAttribute("color", "#000000");
  }

  function createBPMControls() {
    const width = 0.5;
    const height = 0.3;
    const x = -4.5;
    const y = -1.5;
    const z = 0.1;
    const labelZOffset = 0.11;
    const buttonColor = "#888888";
    const bpmDecreaseButton = createCube(0.5, 0.3, 0.2, "#888888", x, -1.5, 0.1);
    const bpmDecreaseButtonLabel = createLabel(
      width,
      height,
      buttonColor,
      "#ddaaaa",
      x,
      y,
      z + labelZOffset,
      "-",
    );
    const bpmIncreaseButton = createCube(
      0.5,
      0.3,
      0.2,
      "#888888",
      x + width + buttonsGap,
      -1.5,
      0.1,
    );
    const bpmIncreaseButtonLabel = createLabel(
      width,
      height,
      buttonColor,
      "#aaddaa",
      x + width + buttonsGap,
      y,
      z + labelZOffset,
      "+",
    );

    const bpmDisplayBorder = createCube(1.13, 0.33, 0.2, "#000000", -3, -1.5, 0.05);
    bpmDisplay = createLabel(1.1, 0.3, "#121212", "#ccffcc", -3, -1.5, 0.16, `${initialBPM} BPM`);

    const prompt = document.createElement("m-prompt");
    prompt.setAttribute("id", "bpm-prompt");
    prompt.setAttribute("message", "Enter the desired BPM");
    prompt.setAttribute("placeholder", "120");
    prompt.setAttribute("prefill", "");
    prompt.addEventListener("prompt", (e) => {
      if (!isNaN(parseFloat(e.detail.value))) {
        initialBPM = parseFloat(e.detail.value);
        if (initialBPM > maxBPM) {
          initialBPM = maxBPM;
        }
        if (initialBPM < minBPM) {
          initialBPM = minBPM;
        }
        if (bpmDisplay) {
          prompt.setAttribute("placeholder", initialBPM);
          bpmDisplay.setAttribute("content", `${initialBPM} BPM`);
        }
        animateBorders(initialBPM);
      } else {
        console.log(`NAN: ${e.detail.value}`);
      }
    });

    prompt.appendChild(bpmDisplay);
    sequencerGroup.appendChild(prompt);

    bpmDecreaseButtonLabel.addEventListener("click", () => {
      decreaseBPM();
    });
    bpmIncreaseButtonLabel.addEventListener("click", () => {
      increaseBPM();
    });

    sequencerGroup.appendChild(bpmDecreaseButton);
    sequencerGroup.appendChild(bpmDecreaseButtonLabel);
    sequencerGroup.appendChild(bpmIncreaseButton);
    sequencerGroup.appendChild(bpmIncreaseButtonLabel);
    sequencerGroup.appendChild(bpmDisplayBorder);
  }

  function createBody() {
    const body = createCube(12, 4, 0.25, "#212121");
    const texture = document.createElement("m-image");
    texture.setAttribute("src", "/assets/playground/808.jpg");
    texture.setAttribute("width", 12);
    texture.setAttribute("height", 4);
    texture.setAttribute("z", 0.13);
    texture.setAttribute("opacity", 0.12);
    body.appendChild(texture);
    sequencerGroup.appendChild(body);
  }

  function increaseBPM() {
    if (initialBPM < maxBPM) {
      const newValue = initialBPM + bpmStep;
      const remainder = newValue % 5;
      initialBPM = remainder === 0 ? newValue : newValue - remainder;
      if (bpmDisplay) {
        bpmDisplay.setAttribute("content", `${initialBPM} BPM`);
      }
      const prompt = document.getElementById("bpm-prompt");
      if (prompt) {
        prompt.setAttribute("placeholder", initialBPM);
      }
      animateBorders(initialBPM);
    }
  }

  function decreaseBPM() {
    if (initialBPM > minBPM) {
      const newValue = initialBPM - bpmStep;
      const remainder = newValue % 5;
      initialBPM = remainder === 0 ? newValue : newValue - remainder;
      if (initialBPM < newValue) {
        initialBPM += 5;
      }
      if (bpmDisplay) {
        bpmDisplay.setAttribute("content", `${initialBPM} BPM`);
      }
      const prompt = document.getElementById("bpm-prompt");
      if (prompt) {
        prompt.setAttribute("placeholder", initialBPM);
      }
      animateBorders(initialBPM);
    }
  }

  function createChannel(bars) {
    const channelIndex = channels.size;

    const channelGroupFrame = document.createElement("m-frame");
    channelGroupFrame.setAttribute("min-x", -6);
    channelGroupFrame.setAttribute("max-x", 6);
    channelGroupFrame.setAttribute("min-y", -2);
    channelGroupFrame.setAttribute("max-y", 2);
    channelGroupFrame.setAttribute("min-z", 0);
    channelGroupFrame.setAttribute("max-z", 0.25);
    channelGroupFrame.setAttribute("debug", false);

    const borderSize = buttonSize + buttonSize * 0.12;
    const borderDepth = buttonSize * 0.2;
    const channelXSize = bars * buttonSize + (bars - 1) * buttonsGap;
    const channelsYSize = instruments * buttonSize + (instruments - 1) * buttonsGap;

    const yIdx = channelIndex + 1;
    let xPos = -channelXSize / 2 + buttonSize / 2;
    const yPos = (buttonSize + buttonsGap) * yIdx - channelsYSize / 2 - buttonSize / 2 - buttonsGap;
    const zPos = buttonSize * 0.1 + 0.1;

    const barsArray = [];

    for (let i = 0; i < bars; i++) {
      const bar = {};
      const hue = (360 / bars) * i;
      const color = `hsl(${hue}, ${offSatLight})`;
      const border = createCube(borderSize, borderSize, borderDepth, "#ffffff", xPos, yPos, zPos);
      const button = createCube(
        buttonSize,
        buttonSize,
        borderDepth,
        color,
        xPos,
        yPos,
        zPos + 0.03,
      );
      button.setAttribute("class", "off");
      button.addEventListener("click", () => {
        toggleButtonLed(button);
      });
      bar.channel = channelIndex;
      bar.borderMesh = border;
      bar.buttonMesh = button;
      barsArray.push(bar);
      channelGroupFrame.appendChild(border);
      channelGroupFrame.appendChild(button);
      xPos += buttonSize + buttonsGap;
    }
    sequencerGroup.appendChild(channelGroupFrame);
    return barsArray;
  }

  function createChannels() {
    for (let i = 0; i < instruments; i++) {
      const channelArray = createChannel(bars);
      channels.set(i, channelArray);
    }
  }

  function createSequencer() {
    createBody();
    createBPMControls();
    createChannels();
  }

  createSequencer();
  animateBorders(initialBPM);
</script>
