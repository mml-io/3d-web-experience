<m-group id="conway-frame"></m-group>
<m-group id="cubes-group" ry="90"></m-group>

<script>
  const cubesGroup = document.getElementById("cubes-group");
  const conwayFrame = document.getElementById("conway-frame");

  const worldSizeX = 19; // Number of cells horizontally
  const worldSizeY = 16; // Number of cells vertically
  const squareSize = 6;
  const cellWidth = squareSize / worldSizeX;
  const cellHeight = squareSize / worldSizeY;

  const visibleOpacity = 1;
  const invisibleOpacity = 0;

  let world = new Array(worldSizeX).fill().map(() => Array(worldSizeY).fill(0));
  const spawnChance = 0.3333334;
  let stepCount = 0;

  const cubesMap = new Map();
  const statesHistory = new Set();

  let currentCellCount = 0;
  const latestCellCount = [];

  function getID(x, y) {
    return `x:${x}-y:${y}`;
  }

  function initializeCubes() {
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        let red = Math.floor((x / worldSizeX) * 255);
        let green = Math.floor((y / worldSizeY) * 255);
        let blue = 128;
        const color = `#${("0" + red.toString(16)).slice(-2)}${("0" + green.toString(16)).slice(-2)}${("0" + blue.toString(16)).slice(-2)}`;
        const cubeID = getID(x, y);
        const cube = document.createElement("m-cube");
        cube.id = cubeID;
        cube.setAttribute("x", (x - worldSizeX / 2) * cellWidth + cellWidth / 2);
        cube.setAttribute("y", cellHeight * y + cellHeight / 2);
        cube.setAttribute("z", 0);
        cube.setAttribute("color", color);
        cube.setAttribute("sx", cellWidth);
        cube.setAttribute("sy", cellHeight);
        cube.setAttribute("sz", 0.25);
        cube.setAttribute("collide", false);
        cube.setAttribute("cast-shadows", false);
        cube.setAttribute("opacity", invisibleOpacity);
        cubesMap.set(cubeID, cube);
        cubesGroup.appendChild(cube);
      }
    }
  }

  function toggleCube(x, y, visible) {
    const cubeID = getID(x, y);
    const cube = document.getElementById(cubeID);
    cube.setAttribute("opacity", visible ? visibleOpacity : invisibleOpacity);
    cube.setAttribute("cast-shadows", visible ? true : false);
  }

  function createCube(x, y) {
    const cubeID = getID(x, y);
    const cubeToCreate = cubesMap.get(cubeID);
    cubeToCreate.setAttribute("opacity", visibleOpacity);
    cubeToCreate.setAttribute("cast-shadows", true);
  }

  function deleteCube(x, y) {
    const cubeID = getID(x, y);
    const cubeToDelete = cubesMap.get(cubeID);
    if (cubeToDelete) {
      cubeToDelete.setAttribute("opacity", invisibleOpacity);
      cubeToDelete.setAttribute("cast-shadows", false);
    }
  }

  function initWorld() {
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        world[x][y] = Math.random() < spawnChance ? 1 : 0;
        toggleCube(x, y, world[x][y]);
      }
    }
  }

  function resetSimulation() {
    statesHistory.clear();
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        world[x][y] = Math.random() < spawnChance ? 1 : 0;
        toggleCube(x, y, world[x][y]);
      }
    }
    stepCount = 0;
  }

  function update() {
    const newWorld = new Array(worldSizeX).fill().map(() => Array(worldSizeY).fill(0));
    let hash = "";
    let aliveCells = 0;
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        const nn = countNeighbours(x, y);
        const alive = world[x][y] === 1;
        if (alive && (nn < 2 || nn > 3)) {
          newWorld[x][y] = 0;
        } else if (!alive && nn === 3) {
          newWorld[x][y] = 1;
        } else {
          newWorld[x][y] = world[x][y];
        }

        if (newWorld[x][y] === 1) {
          aliveCells++;
        }
        hash += `${newWorld[x][y]}`;

        if (newWorld[x][y]) {
          if (!alive) createCube(x, y);
        } else if (alive) {
          deleteCube(x, y);
        }
      }
    }
    currentCellCount = aliveCells;
    latestCellCount.push(currentCellCount);
    if (latestCellCount.length > 1000) {
      latestCellCount.shift();
    }

    world = newWorld;
    stepCount++;

    let stuckWithGliders = false;
    if (stepCount % 100 === 0) {
      stuckWithGliders = latestCellCount.every((num) => num === latestCellCount[0]);
    }

    if (statesHistory.has(hash) || stuckWithGliders) {
      resetSimulation();
    } else {
      statesHistory.add(hash);
    }

    if (statesHistory.size > 2) {
      statesHistory.delete(statesHistory.values().next().value);
    }
  }

  function countNeighbours(x, y) {
    let count = 0;
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;
        const nx = (x + dx + worldSizeX) % worldSizeX;
        const ny = (y + dy + worldSizeY) % worldSizeY;
        count += world[nx][ny];
      }
    }
    return count;
  }

  initializeCubes();
  initWorld();
  window.setInterval(update, 210);
</script>
