<m-group id="conway-frame" ry="-90" x="0.31" y="-0.3" z="0"></m-group>
<m-group id="cubes-group" ry="90"></m-group>

<script>
  const cubesGroup = document.getElementById("cubes-group");
  const conwayFrame = document.getElementById("conway-frame");

  const worldSizeX = 19; // Number of cells horizontally
  const worldSizeY = 16; // Number of cells vertically
  const squareSize = 6;
  const cellWidth = squareSize / worldSizeX;
  const cellHeight = squareSize / worldSizeY;

  const visibleOpacity = 1;
  const invisibleOpacity = 0;

  let world = new Array(worldSizeX).fill().map(() => Array(worldSizeY).fill(0));
  const spawnChance = 0.3333334;
  let stepCount = 0;

  const cubesMap = new Map();
  const statesHistory = new Set();

  let currentCellCount = 0;
  const latestCellCount = [];

  function getID(x, y) {
    return `x:${x}-y:${y}`;
  }

  function createResetButton() {
    let buttonSoundCanPlay = true;
    const buttonSound = document.createElement("m-audio");
    const buttonSoundDuration = 1200;
    const buttonAnimDuration = 210;

    // https://mmleditor.com/projects/interaction-button-45Zy2b
    const buttonBaseURL =
      "https://mmlstorage.com/26c684816caf7c5ac67ff924b1bf8b0d1a982cedbc11bda4f9b1c54bee8f1bf1"; // open_button_base.glb
    const buttonOnURL =
      "https://mmlstorage.com/e06ed8f36e64a28c0d543aeca9d1bcd440b31cdfc1a93aaf91326bf583b02240"; // open_button_on.glb
    const buttonOffURL =
      "https://mmlstorage.com/4b1d2fe8a0f2c6b3e732966e94d5b9366f4a2e9e094d476819e5b66a907a4c90"; // open_button_off.glb

    const scale = (element, size) => {
      element.setAttribute("sx", size);
      element.setAttribute("sy", size);
      element.setAttribute("sz", size);
    };

    const swap = (elementA, elementB) => {
      scale(elementB, 1.0);
      scale(elementA, 0.001);
    };

    const animateElement = (element, attr, start, end, duration, easing) => {
      const buttonAnim = document.createElement("m-attr-anim");
      buttonAnim.setAttribute("attr", attr);
      buttonAnim.setAttribute("start", start);
      buttonAnim.setAttribute("end", end);
      buttonAnim.setAttribute("start-time", document.timeline.currentTime);
      buttonAnim.setAttribute("end-time", document.timeline.currentTime + duration);
      buttonAnim.setAttribute("duration", duration);
      buttonAnim.setAttribute("easing", easing);
      buttonAnim.setAttribute("loop", false);
      element.appendChild(buttonAnim);
      setTimeout(() => {
        element.setAttribute(attr, end);
        element.removeChild(buttonAnim);
      }, duration);
    };

    const buttonBase = document.createElement("m-model");
    buttonBase.setAttribute("src", buttonBaseURL);
    conwayFrame.appendChild(buttonBase);

    const buttonOn = document.createElement("m-model");
    buttonOn.setAttribute("src", buttonOnURL);
    conwayFrame.appendChild(buttonOn);

    const buttonOff = document.createElement("m-model");
    buttonOff.setAttribute("src", buttonOffURL);
    scale(buttonOff, 0.001);
    conwayFrame.appendChild(buttonOff);

    const pushButtonAnim = () => {
      animateElement(buttonOn, "z", 0, 0.03, buttonAnimDuration, "easeInOutCubic");
    };

    const releaseButtonAnim = () => {
      animateElement(buttonOn, "z", 0.03, 0, buttonAnimDuration, "easeInOutCubic");
    };

    const setupButtonSound = () => {
      buttonSound.setAttribute("y", 1.2);
      buttonSound.setAttribute("loop", false);
      buttonSound.setAttribute("debug", false);
      buttonSound.setAttribute(
        "src",
        "https://mmlstorage.com/18cf8bddaf0b8dcd93548433637216e3dd086bd3510f00cf83fffc1508932344",
      ); // button_sfx.mp3
      buttonSound.setAttribute("volume", 0);
      buttonSound.setAttribute("start-time", document.timeline.currentTime - buttonSoundDuration);
      buttonSound.setAttribute("pause-time", document.timeline.currentTime);
      buttonBase.appendChild(buttonSound);
    };
    setupButtonSound();

    const playButtonSound = () => {
      if (buttonSoundCanPlay === false) {
        return;
      }
      buttonSoundCanPlay === false;
      const now = document.timeline.currentTime;
      buttonSound.setAttribute("volume", 2);
      buttonSound.setAttribute("start-time", now);
      buttonSound.setAttribute("pause-time", now + buttonSoundDuration);
      setTimeout(() => {
        buttonSound.setAttribute("volume", 0);
        buttonSoundCanPlay === true;
      }, buttonSoundDuration);
    };

    buttonOn.addEventListener("click", () => {
      pushButtonAnim();
      resetSimulation();
      setTimeout(() => {
        releaseButtonAnim();
        setTimeout(() => swap(buttonOn, buttonOff), buttonAnimDuration + 20);
        setTimeout(() => swap(buttonOff, buttonOn), buttonAnimDuration + 240);
      }, buttonAnimDuration + 20);
      playButtonSound();
    });
  }

  function initializeCubes() {
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        let red = Math.floor((x / worldSizeX) * 255);
        let green = Math.floor((y / worldSizeY) * 255);
        let blue = 128;
        const color = `#${("0" + red.toString(16)).slice(-2)}${("0" + green.toString(16)).slice(-2)}${("0" + blue.toString(16)).slice(-2)}`;
        const cubeID = getID(x, y);
        const cube = document.createElement("m-cube");
        cube.id = cubeID;
        cube.setAttribute("x", (x - worldSizeX / 2) * cellWidth + cellWidth / 2);
        cube.setAttribute("y", cellHeight * y + cellHeight / 2);
        cube.setAttribute("z", 0);
        cube.setAttribute("color", color);
        cube.setAttribute("sx", cellWidth);
        cube.setAttribute("sy", cellHeight);
        cube.setAttribute("sz", 0.25);
        cube.setAttribute("collide", false);
        cube.setAttribute("cast-shadows", false);
        cube.setAttribute("opacity", invisibleOpacity);
        cubesMap.set(cubeID, cube);
        cubesGroup.appendChild(cube);
      }
    }
  }

  function toggleCube(x, y, visible) {
    const cubeID = getID(x, y);
    const cube = document.getElementById(cubeID);
    cube.setAttribute("opacity", visible ? visibleOpacity : invisibleOpacity);
    cube.setAttribute("cast-shadows", visible ? true : false);
  }

  function createCube(x, y) {
    const cubeID = getID(x, y);
    const cubeToCreate = cubesMap.get(cubeID);
    cubeToCreate.setAttribute("opacity", visibleOpacity);
    cubeToCreate.setAttribute("cast-shadows", true);
  }

  function deleteCube(x, y) {
    const cubeID = getID(x, y);
    const cubeToDelete = cubesMap.get(cubeID);
    if (cubeToDelete) {
      cubeToDelete.setAttribute("opacity", invisibleOpacity);
      cubeToDelete.setAttribute("cast-shadows", false);
    }
  }

  function initWorld() {
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        world[x][y] = Math.random() < spawnChance ? 1 : 0;
        toggleCube(x, y, world[x][y]);
      }
    }
  }

  function resetSimulation() {
    statesHistory.clear();
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        world[x][y] = Math.random() < spawnChance ? 1 : 0;
        toggleCube(x, y, world[x][y]);
      }
    }
    stepCount = 0;
  }

  function update() {
    const newWorld = new Array(worldSizeX).fill().map(() => Array(worldSizeY).fill(0));
    let hash = "";
    let aliveCells = 0;
    for (let x = 0; x < worldSizeX; x++) {
      for (let y = 0; y < worldSizeY; y++) {
        const nn = countNeighbours(x, y);
        const alive = world[x][y] === 1;
        if (alive && (nn < 2 || nn > 3)) {
          newWorld[x][y] = 0;
        } else if (!alive && nn === 3) {
          newWorld[x][y] = 1;
        } else {
          newWorld[x][y] = world[x][y];
        }

        if (newWorld[x][y] === 1) {
          aliveCells++;
        }
        hash += `${newWorld[x][y]}`;

        if (newWorld[x][y]) {
          if (!alive) createCube(x, y);
        } else if (alive) {
          deleteCube(x, y);
        }
      }
    }
    currentCellCount = aliveCells;
    latestCellCount.push(currentCellCount);
    if (latestCellCount.length > 1000) {
      latestCellCount.shift();
    }

    world = newWorld;
    stepCount++;

    let stuckWithGliders = false;
    if (stepCount % 100 === 0) {
      stuckWithGliders = latestCellCount.every((num) => num === latestCellCount[0]);
    }

    if (statesHistory.has(hash) || stuckWithGliders) {
      resetSimulation();
    } else {
      statesHistory.add(hash);
    }

    if (statesHistory.size > 2) {
      statesHistory.delete(statesHistory.values().next().value);
    }
  }

  function countNeighbours(x, y) {
    let count = 0;
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx === 0 && dy === 0) continue;
        const nx = (x + dx + worldSizeX) % worldSizeX;
        const ny = (y + dy + worldSizeY) % worldSizeY;
        count += world[nx][ny];
      }
    }
    return count;
  }

  createResetButton();
  initializeCubes();
  initWorld();
  window.setInterval(update, 210);
</script>
